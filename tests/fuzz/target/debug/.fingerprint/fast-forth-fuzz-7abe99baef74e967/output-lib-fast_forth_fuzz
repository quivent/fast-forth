{"$message_type":"diagnostic","message":"6 positional arguments in format string, but there are 5 arguments","code":null,"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":4352,"byte_end":4353,"line_start":155,"line_end":155,"column_start":38,"column_end":39,"is_primary":false,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":38,"highlight_end":39}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4355,"byte_end":4356,"line_start":155,"line_end":155,"column_start":41,"column_end":42,"is_primary":false,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":41,"highlight_end":42}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4358,"byte_end":4361,"line_start":155,"line_end":155,"column_start":44,"column_end":47,"is_primary":false,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":44,"highlight_end":47}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4363,"byte_end":4364,"line_start":155,"line_end":155,"column_start":49,"column_end":50,"is_primary":false,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":49,"highlight_end":50}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4366,"byte_end":4369,"line_start":155,"line_end":155,"column_start":52,"column_end":55,"is_primary":false,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":52,"highlight_end":55}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4332,"byte_end":4334,"line_start":155,"line_end":155,"column_start":18,"column_end":20,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":18,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4335,"byte_end":4337,"line_start":155,"line_end":155,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":21,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4338,"byte_end":4340,"line_start":155,"line_end":155,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":24,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4341,"byte_end":4343,"line_start":155,"line_end":155,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":27,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4344,"byte_end":4346,"line_start":155,"line_end":155,"column_start":30,"column_end":32,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":30,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4347,"byte_end":4349,"line_start":155,"line_end":155,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)","highlight_start":33,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: 6 positional arguments in format string, but there are 5 arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:155:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        format!(\"{} {} {} {} {} {}\", a, b, op1, c, op2)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `OptimizationLevel` and `Optimizer`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/property_tests.rs","byte_start":6783,"byte_end":6792,"line_start":227,"line_end":227,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"    use fastforth_optimizer::{Optimizer, OptimizationLevel};","highlight_start":31,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6794,"byte_end":6811,"line_start":227,"line_end":227,"column_start":42,"column_end":59,"is_primary":true,"text":[{"text":"    use fastforth_optimizer::{Optimizer, OptimizationLevel};","highlight_start":42,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is a test module, consider adding a `#[cfg(test)]` to the containing module","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":198,"byte_end":221,"line_start":6,"line_end":6,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub mod property_tests;","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":6757,"byte_end":6813,"line_start":227,"line_end":227,"column_start":5,"column_end":61,"is_primary":true,"text":[{"text":"    use fastforth_optimizer::{Optimizer, OptimizationLevel};","highlight_start":5,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `OptimizationLevel` and `Optimizer`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:227:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use fastforth_optimizer::{Optimizer, OptimizationLevel};\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if this is a test module, consider adding a `#[cfg(test)]` to the containing module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub mod property_tests;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias takes 1 generic argument but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":4896,"byte_end":4902,"line_start":174,"line_end":174,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":34,"highlight_end":40}],"label":"expected 1 generic argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type alias defined here, with 1 generic parameter: `T`","code":null,"level":"note","spans":[{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":151,"byte_end":152,"line_start":7,"line_end":7,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":17,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":144,"byte_end":150,"line_start":7,"line_end":7,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":10,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generic argument","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":4911,"byte_end":4919,"line_start":174,"line_end":174,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":49,"highlight_end":57}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: type alias takes 1 generic argument but 2 generic arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:174:34\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 1 generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: type alias defined here, with 1 generic parameter: `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs:7:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub type Result<T> = std::result::Result<T, CompileError>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias takes 1 generic argument but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5884,"byte_end":5890,"line_start":203,"line_end":203,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"fn parse_gforth_stack(output: &str) -> Result<Vec<i64>, String> {","highlight_start":40,"highlight_end":46}],"label":"expected 1 generic argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type alias defined here, with 1 generic parameter: `T`","code":null,"level":"note","spans":[{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":151,"byte_end":152,"line_start":7,"line_end":7,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":17,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":144,"byte_end":150,"line_start":7,"line_end":7,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":10,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generic argument","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":5899,"byte_end":5907,"line_start":203,"line_end":203,"column_start":55,"column_end":63,"is_primary":true,"text":[{"text":"fn parse_gforth_stack(output: &str) -> Result<Vec<i64>, String> {","highlight_start":55,"highlight_end":63}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: type alias takes 1 generic argument but 2 generic arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:203:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn parse_gforth_stack(output: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 1 generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: type alias defined here, with 1 generic parameter: `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs:7:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub type Result<T> = std::result::Result<T, CompileError>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias takes 1 generic argument but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":6683,"byte_end":6689,"line_start":225,"line_end":225,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"pub fn run_fast_forth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":38,"highlight_end":44}],"label":"expected 1 generic argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type alias defined here, with 1 generic parameter: `T`","code":null,"level":"note","spans":[{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":151,"byte_end":152,"line_start":7,"line_end":7,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":17,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":144,"byte_end":150,"line_start":7,"line_end":7,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":10,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generic argument","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":6698,"byte_end":6706,"line_start":225,"line_end":225,"column_start":53,"column_end":61,"is_primary":true,"text":[{"text":"pub fn run_fast_forth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":53,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: type alias takes 1 generic argument but 2 generic arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:225:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_fast_forth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 1 generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: type alias defined here, with 1 generic parameter: `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs:7:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub type Result<T> = std::result::Result<T, CompileError>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `CompileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5070,"byte_end":5077,"line_start":179,"line_end":179,"column_start":10,"column_end":17,"is_primary":false,"text":[{"text":"        .spawn()","highlight_start":10,"highlight_end":17}],"label":"this can't be annotated with `?` because it has type `Result<_, std::io::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5087,"byte_end":5140,"line_start":180,"line_end":180,"column_start":10,"column_end":63,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Failed to spawn gforth: {}\", e))?;","highlight_start":10,"highlight_end":63}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4896,"byte_end":4920,"line_start":174,"line_end":174,"column_start":34,"column_end":58,"is_primary":false,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":34,"highlight_end":58}],"label":"expected `CompileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5140,"byte_end":5141,"line_start":180,"line_end":180,"column_start":63,"column_end":64,"is_primary":true,"text":[{"text":"        .map_err(|e| format!(\"Failed to spawn gforth: {}\", e))?;","highlight_start":63,"highlight_end":64}],"label":"the trait `From<std::string::String>` is not implemented for `CompileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/property_tests.rs","byte_start":5140,"byte_end":5141,"line_start":180,"line_end":180,"column_start":63,"column_end":64,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Failed to spawn gforth: {}\", e))?;","highlight_start":63,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `CompileError` implements `From<ForthError>`\n  `CompileError` implements `From<OptimizerError>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `CompileError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:180:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `CompileError` because of this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .spawn()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::io::Error>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map_err(|e| format!(\"Failed to spawn gforth: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<std::string::String>` is not implemented for `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::string::String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `CompileError` implements `From<ForthError>`\u001b[0m\n\u001b[0m              `CompileError` implements `From<OptimizerError>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `CompileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5248,"byte_end":5274,"line_start":184,"line_end":184,"column_start":15,"column_end":41,"is_primary":false,"text":[{"text":"        stdin.write_all(code.as_bytes())","highlight_start":15,"highlight_end":41}],"label":"this can't be annotated with `?` because it has type `Result<_, std::io::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5288,"byte_end":5339,"line_start":185,"line_end":185,"column_start":14,"column_end":65,"is_primary":false,"text":[{"text":"            .map_err(|e| format!(\"Failed to write code: {}\", e))?;","highlight_start":14,"highlight_end":65}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4896,"byte_end":4920,"line_start":174,"line_end":174,"column_start":34,"column_end":58,"is_primary":false,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":34,"highlight_end":58}],"label":"expected `CompileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5339,"byte_end":5340,"line_start":185,"line_end":185,"column_start":65,"column_end":66,"is_primary":true,"text":[{"text":"            .map_err(|e| format!(\"Failed to write code: {}\", e))?;","highlight_start":65,"highlight_end":66}],"label":"the trait `From<std::string::String>` is not implemented for `CompileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/property_tests.rs","byte_start":5339,"byte_end":5340,"line_start":185,"line_end":185,"column_start":65,"column_end":66,"is_primary":false,"text":[{"text":"            .map_err(|e| format!(\"Failed to write code: {}\", e))?;","highlight_start":65,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `CompileError` implements `From<ForthError>`\n  `CompileError` implements `From<OptimizerError>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `CompileError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:185:65\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `CompileError` because of this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        stdin.write_all(code.as_bytes())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::io::Error>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|e| format!(\"Failed to write code: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<std::string::String>` is not implemented for `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::string::String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `CompileError` implements `From<ForthError>`\u001b[0m\n\u001b[0m              `CompileError` implements `From<OptimizerError>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `CompileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5356,"byte_end":5381,"line_start":186,"line_end":186,"column_start":15,"column_end":40,"is_primary":false,"text":[{"text":"        stdin.write_all(b\"\\n.s\\nbye\\n\")","highlight_start":15,"highlight_end":40}],"label":"this can't be annotated with `?` because it has type `Result<_, std::io::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5395,"byte_end":5444,"line_start":187,"line_end":187,"column_start":14,"column_end":63,"is_primary":false,"text":[{"text":"            .map_err(|e| format!(\"Failed to write .s: {}\", e))?;","highlight_start":14,"highlight_end":63}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4896,"byte_end":4920,"line_start":174,"line_end":174,"column_start":34,"column_end":58,"is_primary":false,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":34,"highlight_end":58}],"label":"expected `CompileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5444,"byte_end":5445,"line_start":187,"line_end":187,"column_start":63,"column_end":64,"is_primary":true,"text":[{"text":"            .map_err(|e| format!(\"Failed to write .s: {}\", e))?;","highlight_start":63,"highlight_end":64}],"label":"the trait `From<std::string::String>` is not implemented for `CompileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/property_tests.rs","byte_start":5444,"byte_end":5445,"line_start":187,"line_end":187,"column_start":63,"column_end":64,"is_primary":false,"text":[{"text":"            .map_err(|e| format!(\"Failed to write .s: {}\", e))?;","highlight_start":63,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `CompileError` implements `From<ForthError>`\n  `CompileError` implements `From<OptimizerError>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `CompileError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:187:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `CompileError` because of this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        stdin.write_all(b\"\\n.s\\nbye\\n\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::io::Error>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|e| format!(\"Failed to write .s: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<std::string::String>` is not implemented for `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::string::String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `CompileError` implements `From<ForthError>`\u001b[0m\n\u001b[0m              `CompileError` implements `From<OptimizerError>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `CompileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5477,"byte_end":5495,"line_start":190,"line_end":190,"column_start":24,"column_end":42,"is_primary":false,"text":[{"text":"    let output = child.wait_with_output()","highlight_start":24,"highlight_end":42}],"label":"this can't be annotated with `?` because it has type `Result<_, std::io::Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5505,"byte_end":5550,"line_start":191,"line_end":191,"column_start":10,"column_end":55,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Failed to wait: {}\", e))?;","highlight_start":10,"highlight_end":55}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":4896,"byte_end":4920,"line_start":174,"line_end":174,"column_start":34,"column_end":58,"is_primary":false,"text":[{"text":"pub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":34,"highlight_end":58}],"label":"expected `CompileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5550,"byte_end":5551,"line_start":191,"line_end":191,"column_start":55,"column_end":56,"is_primary":true,"text":[{"text":"        .map_err(|e| format!(\"Failed to wait: {}\", e))?;","highlight_start":55,"highlight_end":56}],"label":"the trait `From<std::string::String>` is not implemented for `CompileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/property_tests.rs","byte_start":5550,"byte_end":5551,"line_start":191,"line_end":191,"column_start":55,"column_end":56,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Failed to wait: {}\", e))?;","highlight_start":55,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `CompileError` implements `From<ForthError>`\n  `CompileError` implements `From<OptimizerError>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `CompileError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:191:55\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_gforth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `CompileError` because of this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let output = child.wait_with_output()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::io::Error>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map_err(|e| format!(\"Failed to wait: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<std::string::String>` is not implemented for `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::string::String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `CompileError` implements `From<ForthError>`\u001b[0m\n\u001b[0m              `CompileError` implements `From<OptimizerError>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5658,"line_start":194,"line_end":194,"column_start":20,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":71}],"label":"expected `CompileError`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5603,"byte_end":5606,"line_start":194,"line_end":194,"column_start":16,"column_end":19,"is_primary":false,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":16,"highlight_end":19}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `std::string::String` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5658,"line_start":194,"line_end":194,"column_start":20,"column_end":71,"is_primary":false,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":71}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5603,"byte_end":5659,"line_start":194,"line_end":194,"column_start":16,"column_end":72,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":16,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/result.rs","byte_start":21082,"byte_end":21085,"line_start":557,"line_end":557,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"try wrapping the expression in a variant of `CompileError`","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::ParseError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::SemanticError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::TypeError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::SSAError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::OptimizationError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::CodeGenError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::BackendError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::LLVMError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::RuntimeError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5607,"byte_end":5607,"line_start":194,"line_end":194,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"fastforth::CompileError::InternalError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":5658,"byte_end":5658,"line_start":194,"line_end":194,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"        return Err(String::from_utf8_lossy(&output.stderr).to_string());","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:194:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return Err(String::from_utf8_lossy(&output.stderr).to_string());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `CompileError`, found `String`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the type constructed contains `std::string::String` due to the type of the argument passed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:194:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return Err(String::from_utf8_lossy(&output.stderr).to_string());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the type of `Err`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/result.rs:557:5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in a variant of `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        return Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::ParseError(\u001b[0m\u001b[0mString::from_utf8_lossy(&output.stderr).to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        return Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::SemanticError(\u001b[0m\u001b[0mString::from_utf8_lossy(&output.stderr).to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        return Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::TypeError(\u001b[0m\u001b[0mString::from_utf8_lossy(&output.stderr).to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        return Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::SSAError(\u001b[0m\u001b[0mString::from_utf8_lossy(&output.stderr).to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0mand 6 other candidates\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias takes 1 generic argument but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":6272,"byte_end":6278,"line_start":211,"line_end":211,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"                let values: Result<Vec<i64>, _> = parts[1..]","highlight_start":29,"highlight_end":35}],"label":"expected 1 generic argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"type alias defined here, with 1 generic parameter: `T`","code":null,"level":"note","spans":[{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":151,"byte_end":152,"line_start":7,"line_end":7,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":17,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs","byte_start":144,"byte_end":150,"line_start":7,"line_end":7,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"pub type Result<T> = std::result::Result<T, CompileError>;","highlight_start":10,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generic argument","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":6287,"byte_end":6290,"line_start":211,"line_end":211,"column_start":44,"column_end":47,"is_primary":true,"text":[{"text":"                let values: Result<Vec<i64>, _> = parts[1..]","highlight_start":44,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: type alias takes 1 generic argument but 2 generic arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:211:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let values: Result<Vec<i64>, _> = parts[1..]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 1 generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: type alias defined here, with 1 generic parameter: `T`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/joshkornreich/Documents/Projects/Ollama/llama/variants/fast-forth/src/error.rs:7:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub type Result<T> = std::result::Result<T, CompileError>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"a value of type `std::result::Result<Vec<i64>, CompileError>` cannot be built from an iterator over elements of type `std::result::Result<i64, ParseIntError>`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":6401,"byte_end":6408,"line_start":214,"line_end":214,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"                    .collect();","highlight_start":22,"highlight_end":29}],"label":"value of type `std::result::Result<Vec<i64>, CompileError>` cannot be built from `std::iter::Iterator<Item=std::result::Result<i64, ParseIntError>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `FromIterator<std::result::Result<_, ParseIntError>>` is not implemented for `std::result::Result<Vec<i64>, CompileError>`\nbut trait `FromIterator<std::result::Result<_, CompileError>>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `CompileError`, found `ParseIntError`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the method call chain might not have had the expected associated types","code":null,"level":"note","spans":[{"file_name":"src/property_tests.rs","byte_start":6294,"byte_end":6304,"line_start":211,"line_end":211,"column_start":51,"column_end":61,"is_primary":false,"text":[{"text":"                let values: Result<Vec<i64>, _> = parts[1..]","highlight_start":51,"highlight_end":61}],"label":"this expression has type `[&str]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6354,"byte_end":6379,"line_start":213,"line_end":213,"column_start":22,"column_end":47,"is_primary":true,"text":[{"text":"                    .map(|s| s.parse::<i64>())","highlight_start":22,"highlight_end":47}],"label":"`Iterator::Item` changed to `Result<i64, ParseIntError>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6326,"byte_end":6332,"line_start":212,"line_end":212,"column_start":22,"column_end":28,"is_primary":false,"text":[{"text":"                    .iter()","highlight_start":22,"highlight_end":28}],"label":"`Iterator::Item` is `&&str` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `collect`","code":null,"level":"note","spans":[{"file_name":"/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/iter/traits/iterator.rs","byte_start":67920,"byte_end":68001,"line_start":2014,"line_end":2016,"column_start":5,"column_end":21,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `std::result::Result<Vec<i64>, CompileError>` cannot be built from an iterator over elements of type `std::result::Result<i64, ParseIntError>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:214:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .collect();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `std::result::Result<Vec<i64>, CompileError>` cannot be built from `std::iter::Iterator<Item=std::result::Result<i64, ParseIntError>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `FromIterator<std::result::Result<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mParseIntError\u001b[0m\u001b[0m>>` \u001b[0m\u001b[0m\u001b[1m\u001b[35mis not\u001b[0m\u001b[0m implemented for `std::result::Result<Vec<i64>, CompileError>`\u001b[0m\n\u001b[0m            but trait `FromIterator<std::result::Result<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mCompileError\u001b[0m\u001b[0m>>` \u001b[0m\u001b[0m\u001b[1m\u001b[35mis\u001b[0m\u001b[0m implemented for it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for that trait implementation, expected `\u001b[0m\u001b[0m\u001b[1m\u001b[35mCompileError\u001b[0m\u001b[0m`, found `\u001b[0m\u001b[0m\u001b[1m\u001b[35mParseIntError\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the method call chain might not have had the expected associated types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:213:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let values: Result<Vec<i64>, _> = parts[1..]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis expression has type `[&str]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .iter()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`Iterator::Item` is `&&str` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .map(|s| s.parse::<i64>())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m`Iterator::Item` changed to `Result<i64, ParseIntError>` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `collect`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/iter/traits/iterator.rs:2014:5\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":6435,"byte_end":6484,"line_start":215,"line_end":215,"column_start":24,"column_end":73,"is_primary":true,"text":[{"text":"                return values.map_err(|e| format!(\"Parse error: {}\", e));","highlight_start":24,"highlight_end":73}],"label":"expected `Result<Vec<i64>, CompileError>`, found `Result<Vec<i64>, String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":5884,"byte_end":5908,"line_start":203,"line_end":203,"column_start":40,"column_end":64,"is_primary":false,"text":[{"text":"fn parse_gforth_stack(output: &str) -> Result<Vec<i64>, String> {","highlight_start":40,"highlight_end":64}],"label":"expected `std::result::Result<Vec<i64>, CompileError>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::result::Result<_, CompileError>`\n   found enum `std::result::Result<_, std::string::String>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:215:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn parse_gforth_stack(output: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `std::result::Result<Vec<i64>, CompileError>` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                return values.map_err(|e| format!(\"Parse error: {}\", e));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Vec<i64>, CompileError>`, found `Result<Vec<i64>, String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `std::result::Result<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mCompileError\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found enum `std::result::Result<_, \u001b[0m\u001b[0m\u001b[1m\u001b[35mstd::string::String\u001b[0m\u001b[0m>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `CompileError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":6855,"byte_end":6874,"line_start":230,"line_end":230,"column_start":19,"column_end":38,"is_primary":false,"text":[{"text":"    let program = parse_program(code)","highlight_start":19,"highlight_end":38}],"label":"this has type `Result<_, ForthError>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6884,"byte_end":6926,"line_start":231,"line_end":231,"column_start":10,"column_end":52,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Parse error: {}\", e))?;","highlight_start":10,"highlight_end":52}],"label":"this can't be annotated with `?` because it has type `Result<_, std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6683,"byte_end":6707,"line_start":225,"line_end":225,"column_start":38,"column_end":62,"is_primary":false,"text":[{"text":"pub fn run_fast_forth(code: &str) -> Result<Vec<i64>, String> {","highlight_start":38,"highlight_end":62}],"label":"expected `CompileError` because of this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":6926,"byte_end":6927,"line_start":231,"line_end":231,"column_start":52,"column_end":53,"is_primary":true,"text":[{"text":"        .map_err(|e| format!(\"Parse error: {}\", e))?;","highlight_start":52,"highlight_end":53}],"label":"the trait `From<std::string::String>` is not implemented for `CompileError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/property_tests.rs","byte_start":6926,"byte_end":6927,"line_start":231,"line_end":231,"column_start":52,"column_end":53,"is_primary":false,"text":[{"text":"        .map_err(|e| format!(\"Parse error: {}\", e))?;","highlight_start":52,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `From<T>`:\n  `CompileError` implements `From<ForthError>`\n  `CompileError` implements `From<OptimizerError>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `CompileError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:231:52\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m225\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn run_fast_forth(code: &str) -> Result<Vec<i64>, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `CompileError` because of this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let program = parse_program(code)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis has type `Result<_, ForthError>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map_err(|e| format!(\"Parse error: {}\", e))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<std::string::String>` is not implemented for `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis can't be annotated with `?` because it has type `Result<_, std::string::String>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              `CompileError` implements `From<ForthError>`\u001b[0m\n\u001b[0m              `CompileError` implements `From<OptimizerError>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7174,"line_start":237,"line_end":237,"column_start":9,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":69}],"label":"expected `CompileError`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":7110,"byte_end":7113,"line_start":237,"line_end":237,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":5,"highlight_end":8}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `std::string::String` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7174,"line_start":237,"line_end":237,"column_start":9,"column_end":69,"is_primary":false,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":69}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/property_tests.rs","byte_start":7110,"byte_end":7175,"line_start":237,"line_end":237,"column_start":5,"column_end":70,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":5,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/result.rs","byte_start":21082,"byte_end":21085,"line_start":557,"line_end":557,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"try wrapping the expression in a variant of `CompileError`","code":null,"level":"help","spans":[{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::ParseError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::SemanticError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::TypeError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::SSAError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::OptimizationError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::CodeGenError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::BackendError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::LLVMError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::RuntimeError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7114,"byte_end":7114,"line_start":237,"line_end":237,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"fastforth::CompileError::InternalError(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/property_tests.rs","byte_start":7174,"byte_end":7174,"line_start":237,"line_end":237,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"    Err(\"Fast Forth execution not fully implemented yet\".to_string())","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:237:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Err(\"Fast Forth execution not fully implemented yet\".to_string())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `CompileError`, found `String`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the type constructed contains `std::string::String` due to the type of the argument passed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/property_tests.rs:237:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Err(\"Fast Forth execution not fully implemented yet\".to_string())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------------------------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the type of `Err`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/result.rs:557:5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in a variant of `CompileError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::ParseError(\u001b[0m\u001b[0m\"Fast Forth execution not fully implemented yet\".to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::SemanticError(\u001b[0m\u001b[0m\"Fast Forth execution not fully implemented yet\".to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::TypeError(\u001b[0m\u001b[0m\"Fast Forth execution not fully implemented yet\".to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Err(\u001b[0m\u001b[0m\u001b[38;5;10mfastforth::CompileError::SSAError(\u001b[0m\u001b[0m\"Fast Forth execution not fully implemented yet\".to_string()\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++\u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0mand 6 other candidates\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 14 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 14 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0107, E0277, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0107, E0277, E0308.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0107`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0107`.\u001b[0m\n"}
