================================================================================
STREAM 5: TYPE-DRIVEN SPECIALIZATION ARCHITECTURE DIAGRAM
================================================================================

OVERALL SYSTEM ARCHITECTURE
================================================================================

    Frontend Type Inference
             |
             | (produces TypeInferenceResults)
             v
    ┌──────────────────────────────────┐
    │  Type Specializer Engine         │  ← STREAM 5 Implementation
    │  (type_specialization.rs)        │
    ├──────────────────────────────────┤
    │ Phase 1: Type Analysis           │
    │   - Analyze type info            │
    │   - Build usage profiles         │
    │   - Identify polymorphic words   │
    │   - Track type signatures        │
    ├──────────────────────────────────┤
    │ Phase 2: Specialization Gen      │
    │   - Generate type variants       │
    │   - Create monomorphic code      │
    │   - Apply type-specific opts     │
    │   - Eliminate dispatch           │
    ├──────────────────────────────────┤
    │ Phase 3: Call Site Rewriting     │
    │   - Replace with specialized     │
    │   - Update references            │
    │   - Maintain type safety         │
    └──────────────────────────────────┘
             |
             | (produces specialized IR)
             v
    Downstream Optimizations
    (constant folding, inlining, etc.)


TYPE SPECIALIZATION PIPELINE
================================================================================

Input: Polymorphic Forth Code + Type Information

    : SQUARE DUP * ;      Type: Int → [Int] = [Int]
    : SQUARE DUP * ;      Type: Float → [Float] = [Float]


Step 1: Type Analysis
────────────────────────────────────────────────────────

    Word: SQUARE
    ├─ Signature 1: Int → Int (called 5 times)
    ├─ Signature 2: Float → Float (called 3 times)
    └─ Status: POLYMORPHIC ✓ (2 different types)


Step 2: Specialization Generation
────────────────────────────────────────────────────────

    Generate SQUARE_INT (int -- int)
    └─ DUP (type-aware)
    └─ IMUL (integer multiply)

    Generate SQUARE_FLOAT (float -- float)
    └─ DUP (type-aware)
    └─ FMUL (float multiply)


Step 3: Call Site Rewriting
────────────────────────────────────────────────────────

    5 SQUARE        → 5 SQUARE_INT
    3.14 SQUARE     → 3.14 SQUARE_FLOAT


Output: Monomorphic Specialized Code

    SQUARE_INT:    DUP IMUL
    SQUARE_FLOAT:  DUP FMUL
    (No runtime dispatch needed)


INSTRUCTION SPECIALIZATION MATRIX
================================================================================

Operation       │  Int Type        │  Float Type      │  Addr Type
────────────────┼──────────────────┼──────────────────┼──────────────
ADD             │  add (x86)       │  fadd (SSE/AVX)  │  add ptr
SUB             │  sub (x86)       │  fsub (SSE/AVX)  │  sub ptr
MUL             │  imul (x86)      │  fmul (SSE/AVX)  │  (N/A)
DIV             │  sdiv (x86)      │  fdiv (SSE/AVX)  │  (N/A)
MOD             │  smod (x86)      │  (N/A)           │  (N/A)
────────────────┼──────────────────┼──────────────────┼──────────────
<               │  icmp slt        │  fcmp olt        │  icmp slt
>               │  icmp sgt        │  fcmp ogt        │  icmp sgt
==              │  icmp eq         │  fcmp oeq        │  icmp eq
!= (ne)         │  icmp ne         │  fcmp one        │  icmp ne
────────────────┼──────────────────┼──────────────────┼──────────────
DUP             │  (type-agnostic, stack register hint provided)
DROP            │  (type-agnostic, can know size)
SWAP            │  (type-agnostic, register allocation hint)
────────────────┼──────────────────┼──────────────────┼──────────────
LOAD            │  i64 load        │  f64 load        │  ptr load
STORE           │  i64 store       │  f64 store       │  ptr store
────────────────┼──────────────────┼──────────────────┼──────────────


CONCRETE TYPE HIERARCHY
================================================================================

                    ConcreteType
                         |
         ┌───────────────┼───────────────┬─────────────┬─────────┐
         |               |               |             |         |
       Int           Float             Addr          Bool      Char    String
       (64-bit)    (IEEE 754)     (Pointer)       (Int-1)     (u8)    (Ref)
         |               |               |             |         |         |
    add, imul,     fadd, fmul,     Pointer ops   Boolean ops Char ops String ops
    sdiv, smod     fdiv, cmp       addr math      bitwise
    icmp           fcmp


OPTIMIZATION PIPELINE INTEGRATION
================================================================================

Traditional Pipeline:
    ┌─────────────────────────────────────────────────┐
    │ Input: Forth Code (potentially polymorphic)    │
    └──────────────────┬──────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────┐
    │ Constant Folding (generic code)                 │
    └──────────────────┬──────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────┐
    │ Inlining (dispatch overhead in inlined code)    │
    └──────────────────┬──────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────┐
    │ Stack Caching (complex with mixed types)        │
    └──────────────────┬──────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────┐
    │ Output: Generic code with dispatch overhead     │
    └─────────────────────────────────────────────────┘


WITH TYPE SPECIALIZATION (Stream 5):
    ┌─────────────────────────────────────────────────────┐
    │ Input: Forth Code + Type Information               │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ TYPE SPECIALIZATION ← NEW (monomorphizes code)     │ ← EARLY PLACEMENT
    │  - Eliminates dispatch (10% speedup)              │   Enables all
    │  - Creates type-specific variants                 │   downstream opts
    │  - Simplifies code analysis                       │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Constant Folding (monomorphic code, better opt)    │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Inlining (safer with monomorphic, type hints)      │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Superinstruction Recognition (patterns clearer)    │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Dead Code Elimination (more effective)             │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Memory Optimization (better alias analysis)        │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Stack Caching (knows types, better registers)      │
    └──────────────────┬─────────────────────────────────┘
                       v
    ┌─────────────────────────────────────────────────────┐
    │ Output: Specialized monomorphic code (15-20% faster)│
    └─────────────────────────────────────────────────────┘


PERFORMANCE IMPACT BREAKDOWN
================================================================================

                 Speedup Factor                Total Impact
              ┌────────────────┐
              │ 10% Dispatch   │           15-20%
              │ Elimination    │   ┌─────────────────┐
              │ (runtime checks)   │ Overall Speed   │
    ┌─────────┼────────────────┤   │ Improvement     │
    │ 3-7%    │ Type-Specific  │───┤ (Typical: 15-18%
    │ Opt     │ Optimization   │   │ Maximum: 20%)   │
    │ (LLVM)  │ (monomorphic)  │   └─────────────────┘
    ├─────────┼────────────────┤
    │ 2-5%    │ Specialized    │
    │ Inst    │ Instructions   │
    │ Select  │ (native ops)   │
    └─────────┴────────────────┘

Code Size Trade-off: +10-15% (acceptable for performance gain)


DATA STRUCTURE RELATIONSHIPS
================================================================================

            TypeInferenceResults
                    |
        ┌───────────┴────────────┐
        |                        |
     word_signatures      call_site_signatures
     [word → signature]   [call_idx → signature]
             |                   |
             v                   v
       TypeSpecializer
              |
     ┌────────┼────────┐
     v        v        v
  Phase1   Phase2   Phase3
  Analyze  Generate Rewrite
     |        |        |
     v        v        v
  profiles  specials  rewrites
     |        |        |
     └────────┴────────┘
            |
            v
       SpecializationStats
       (metrics & results)


CALL SITE SPECIALIZATION EXAMPLE
================================================================================

Before Specialization:
─────────────────────

: CALC-VECTOR
  5 SQUARE         ← generic dispatch
  3.14 SQUARE      ← generic dispatch
  + .
;

IR representation (dispatch points):
  Literal(5)
  Call(SQUARE)       ← runtime dispatch check
  Literal(3.14)
  Call(SQUARE)       ← runtime dispatch check
  Add
  Print


After Specialization:
─────────────────────

: CALC-VECTOR
  5 SQUARE_INT      ← direct monomorphic call
  3.14 SQUARE_FLOAT ← direct monomorphic call
  + .
;

IR representation (no dispatch):
  Literal(5)
  Call(SQUARE_INT)   ← direct, no dispatch needed
  Literal(3.14)
  Call(SQUARE_FLOAT) ← direct, no dispatch needed
  Add
  Print

Benefit: 10% faster due to dispatch elimination


NAME MANGLING SCHEME
================================================================================

Base Word Name
     |
     v
WORD_NAME + "_" + TYPE_SUFFIX

Type Suffix Format:
  Single Type: INPUT_TYPE
    Example: SQUARE_INT

  Multiple Types: INPUT1_INPUT2_...
    Example: ADD_INT_INT
             MAX_INT_INT

Type Abbreviations:
  INT    → Integer (64-bit)
  FLOAT  → Floating-point (IEEE 754)
  ADDR   → Address/Pointer
  BOOL   → Boolean
  CHAR   → Character
  STRING → String reference


Complete Examples:

  SQUARE + [Int → Int]           → SQUARE_INT
  SQUARE + [Float → Float]       → SQUARE_FLOAT
  ADD + [Int, Int → Int]         → ADD_INT_INT
  ADD + [Float, Float → Float]   → ADD_FLOAT_FLOAT
  DUP + [Int]                    → DUP_INT
  DUP + [Float]                  → DUP_FLOAT
  VECTOR-DOT + [Addr, Addr, Int] → VECTOR-DOT_ADDR


STATISTICS COLLECTION FLOW
================================================================================

TypeInferenceResults
     |
     v
Phase 1: Type Analysis
     |
     +─→ words_analyzed++
     +─→ polymorphic_words count
     +─→ call_site collection
     |
     v
Phase 2: Specialization Generation
     |
     +─→ specializations_created++
     +─→ int_specializations++
     +─→ float_specializations++
     +─→ dispatch_eliminations++
     +─→ avg_specialized_size calc
     |
     v
Phase 3: Call Site Rewriting
     |
     +─→ call_sites_rewritten++
     |
     v
Statistics Calculation
     |
     +─→ calculate_speedup()
     +─→ estimate_code_size_impact()
     |
     v
SpecializationStats Output
     |
     └─→ Display formatted results


================================================================================
END OF ARCHITECTURE DIAGRAM
================================================================================
